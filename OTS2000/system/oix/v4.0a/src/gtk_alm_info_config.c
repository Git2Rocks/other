/*
 * DO NOT EDIT THIS FILE - it is generated by Glade.
 */
 
  /*-----------------------------------------------------------------------
	 
  have been SYNC
	Date : 2007.11.27 
	---------------------------------------------------------------------*/

#include <gtk/gtk.h>
#include <gdk/gdkkeysyms.h>
#include	<gtk/gtk.h>
#include	"../inc/gtk_widgets.h"
#include	"../inc/gtk_ipm_k_def.h"
#include	"../inc/oix.h"

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

extern void	PopupMessageBox (GtkWidget *parent,char msg[] );
extern char *_toUtf8(char *c);
extern char *_toUtf8EX(char *c);

extern SYS_COMM_TABLE  *shm_syscomm_addr;
GtkWidget* alm_info_config_win[MAX_CRT_NUMBER];
BOOL lcu_togglebtn_state[STATION_ENTRY_NUMBER+1][GROUP_ENTRY_NUM_PER_STATION+1];
BOOL  isStnInMask (UCHAR stn_id);
typedef struct 
{
	UCHAR	stn_id;
	UCHAR	dev_id;
}LCU_INFO;

void
on_checkbtn_lcu_toggled               (GtkToggleButton *togglebutton,
                                        gpointer         user_data)
{
    LCU_INFO *lcu_id=(LCU_INFO*)user_data;
    UCHAR	stn_id,dev_id;
    
    stn_id = lcu_id->stn_id;
    dev_id = lcu_id->dev_id;
    lcu_togglebtn_state[stn_id][dev_id] = !gtk_toggle_button_get_active(togglebutton);
}

void DestroyAlmInfoWin( GtkWidget* w, gpointer         user_data)
{
	int crt_n =(int)user_data;
	gtk_widget_destroy(alm_info_config_win[crt_n]);
    alm_info_config_win[crt_n]= NULL;
}

void
on_ok_btn_clicked                      (GtkButton       *button,
                                        gpointer         user_data)
{
    int crt_n =(int)user_data;
    UCHAR i,j;
    int stn_num,grp_num;
	UCHAR stnId;
    
    GetStationNum(&stn_num);   
    for(i=1;i<=stn_num;i++)
    {
		if(-1==GetStnIdByIndex(i, &stnId))
			continue;
		
        if(-1==GetGroupNumById(stnId, &grp_num))
			continue;

        for(j=1;j<=grp_num;j++)        
            shm_syscomm_addr->dev_alm_disable[stnId][j]=lcu_togglebtn_state[stnId][j];
    }
    
    gtk_widget_destroy(alm_info_config_win[crt_n]);
    alm_info_config_win[crt_n]= NULL;
}


void
on_Cancel_btn_clicked                  (GtkButton       *button,
                                        gpointer         user_data)
{
    int crt_n =(int)user_data;
    UCHAR i,j;
    int stn_num,grp_num;
	UCHAR stnId;
    
    GetStationNum(&stn_num);   
    for(i=1;i<=stn_num;i++)
    {      
		if(-1==GetStnIdByIndex(i, &stnId))
			continue;
		
        if(-1==GetGroupNumById(stnId, &grp_num))
			continue;
        for(j=1;j<=grp_num;j++)        
        {
            lcu_togglebtn_state[stnId][j]=shm_syscomm_addr->dev_alm_disable[stnId][j];
        }
    }
    gtk_widget_destroy(alm_info_config_win[crt_n]);
    alm_info_config_win[crt_n]= NULL;
}

GtkWidget* create_alm_info_config_window (int crt_n)
{
  
	GtkWidget *table1;

	GtkWidget *ok_btn;
	GtkWidget *Cancel_btn;
	GtkWidget *checkbtn_lcu;

	UCHAR index,j,stnId;
	int	k,row,col;
	char	dev_comment[GROUP_COMMENT_SIZE];
	char stn_comment[STATION_COMMENT_SIZE];
	char stn_dev_comment[STATION_COMMENT_SIZE+GROUP_COMMENT_SIZE];
	int	stn_num,grp_num;
	static LCU_INFO lcu_info[STATION_ENTRY_NUMBER*GROUP_ENTRY_NUM_PER_STATION];
	BOOL  alm_info_disable[STATION_ENTRY_NUMBER+1][GROUP_ENTRY_NUM_PER_STATION+1];
	gchar *pConvert=0;  

	if(!CheckUserPrivilege(cur_usr_name, PRIV_SYS_CONF_MGR))
	{
		PopupMessageBox ( main_w[crt_n], MSG_SYS_CONFIG_MGR );
		return NULL;
	}
    if(alm_info_config_win[crt_n]!=NULL )
	{
        gtk_window_present(GTK_WINDOW(alm_info_config_win[crt_n]));
        return NULL;
    }
	alm_info_config_win[crt_n] = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	gtk_window_set_title (GTK_WINDOW (alm_info_config_win[crt_n]), pConvert=_toUtf8EX(OIX_CSTR_ALM_INFO_CONFIG));
	G_SAFE_FREE(pConvert);//dzy1017
	gtk_window_set_transient_for(GTK_WINDOW(alm_info_config_win[crt_n]), GTK_WINDOW(main_w[crt_n]));
	gtk_window_set_position(GTK_WINDOW(alm_info_config_win[crt_n]),GTK_WIN_POS_CENTER);
	gtk_widget_show (alm_info_config_win[crt_n]);
	gtk_signal_connect(GTK_OBJECT(alm_info_config_win[crt_n]),
		"destroy",
		GTK_SIGNAL_FUNC(DestroyAlmInfoWin),
		(gpointer)crt_n);

	table1 = gtk_table_new (12, 3, FALSE);
	gtk_widget_show (table1);
	gtk_container_add (GTK_CONTAINER (alm_info_config_win[crt_n]), table1);

	GetStationNum(&stn_num);

	k=0;
	for(index=1;index<=stn_num;index++)
	{      
		if(-1==GetStnIdByIndex(index, &stnId))
			continue;
		
        if(-1==GetGroupNumById(stnId, &grp_num))
			continue;
		if (isStnInMask((UCHAR)stnId)==0) continue ; 

		GetStnCommentById(stnId,stn_comment);

        for(j=1;j<=grp_num;j++)
        {
			if(-1==GetGroupCommentById(stnId, (UCHAR)j, dev_comment))
				continue;
			  sprintf(stn_dev_comment,"%s:%s",stn_comment,dev_comment);
            checkbtn_lcu = gtk_check_button_new_with_mnemonic (pConvert=_toUtf8(stn_dev_comment));
            G_SAFE_FREE(pConvert);//dzy1017
			gtk_widget_show (checkbtn_lcu);
            row = k/10+1;
            col = k%10;
            gtk_table_attach (GTK_TABLE (table1), checkbtn_lcu, row-1, row, col+1, col+2,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
            lcu_togglebtn_state[stnId][j] = shm_syscomm_addr->dev_alm_disable[stnId][j];
            
            gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (checkbtn_lcu), !lcu_togglebtn_state[stnId][j] );
            lcu_info[k].stn_id = stnId;
            lcu_info[k].dev_id = j;
            
            g_signal_connect ((gpointer) checkbtn_lcu, "toggled",
                    G_CALLBACK (on_checkbtn_lcu_toggled),
                    &lcu_info[k]);
            k++;
        }
	}

	ok_btn = gtk_button_new_with_mnemonic (pConvert=_toUtf8EX(OIX_CSTR_OK));
	G_SAFE_FREE(pConvert);
	gtk_widget_show (ok_btn);
	gtk_table_attach (GTK_TABLE (table1), ok_btn, 0, 1, 11, 12,
					  (GtkAttachOptions) (GTK_FILL),
					  (GtkAttachOptions) (0), 0, 0);

	Cancel_btn = gtk_button_new_with_mnemonic (pConvert=_toUtf8EX(OIX_CSTR_CANCEL));
	G_SAFE_FREE(pConvert);
	gtk_widget_show (Cancel_btn);
	gtk_table_attach (GTK_TABLE (table1), Cancel_btn, 2, 3, 11, 12,
					  (GtkAttachOptions) (GTK_FILL),
					  (GtkAttachOptions) (0), 0, 0);

	g_signal_connect ((gpointer) ok_btn, "clicked",
					  G_CALLBACK (on_ok_btn_clicked),
					  (gpointer)crt_n);

	g_signal_connect ((gpointer) Cancel_btn, "clicked",
					  G_CALLBACK (on_Cancel_btn_clicked),
					  (gpointer)crt_n); 

/* Store pointers to all widgets, for use by lookup_widget(). */
/*GLADE_HOOKUP_OBJECT_NO_REF (window1, window1, "window1");
	GLADE_HOOKUP_OBJECT (window1, table1, "table1"); 
*/
	return alm_info_config_win[crt_n];
}

/////////////////////////////////////////////////////////////////////////////


extern UINT stnMask4alarm;//=  0xFFFFFFFF;

GtkWidget *alm_stn_config_win[MAX_CRT_NUM] ; 

void DestroyAlmStnCfgWin( GtkWidget* w, gpointer         user_data)
{
	int crt_n =(int)user_data;
	gtk_widget_destroy(alm_stn_config_win[crt_n]);
    alm_stn_config_win[crt_n]= NULL;
}

BOOL  isStnInMask (UCHAR stn_id)
{
	UCHAR stn_idx;
	
	if(-1==GetStnIndexById(stn_id,&stn_idx))
		return TRUE;
	
	return    (stnMask4alarm  &  (0X1<<(stn_idx-1)))  ; //1 based
}


void on_checkbtn_stn_toggled               (GtkToggleButton *togglebutton,
									   gpointer         user_data)
{
	int i = (unsigned int)user_data ; 
	
    
    //i  = !gtk_toggle_button_get_active(togglebutton);
	if (gtk_toggle_button_get_active  (GTK_TOGGLE_BUTTON(togglebutton)))
		stnMask4alarm  = stnMask4alarm   | (1<<(i-1) )   ;   /*  Set   bit N */
	else
		stnMask4alarm  = stnMask4alarm   & (~(1<<(i-1))) ;   /*  Clear bit N */   
}

int SaveSTNMaskXml(const char *nodeName)
{
	xmlDocPtr   pdoc = NULL;
	xmlNodePtr  proot = NULL,pCurNode = NULL, pOIXInitNode = NULL,pChgNode = NULL,pNewNode=NULL;
	//	GtkTreeIter iter;
	char	err_str[256];
	//	xmlChar *key; 
	gchar *pConvert=0;
	int offset = 0;
	char alm_stn_mask[9];
	char alm_stn_mask_flag=0;
	//char stn_id[2],stn_mask[9],cmd_type[2],fault_mask[9],type_id_mask[9],dev_mask[9],group_mask[450],datatype_mask[9],attrib_mask[18],start_time[30],end_time[30],logic_name[50],long_name[MAX_SEARCH_NAME_SIZE];
	xmlKeepBlanksDefault(0);
	pdoc = xmlReadFile (FILE_OIX_CONFIG_XML, "GB2312", XML_PARSE_NOBLANKS);
	if (pdoc == NULL)
    {
		sprintf(err_str, "Fail to open %s", FILE_OIX_CONFIG_XML);
		Err_log(err_str);
		return -1;
    }
	
	proot = xmlDocGetRootElement (pdoc);
	if (proot == NULL)
    {
		sprintf(err_str, "%s not have root", FILE_OIX_CONFIG_XML);
		Err_log(err_str);
		return -1;
    }

	pCurNode = proot->xmlChildrenNode;
	while (pCurNode != NULL)
    {
		if (!xmlStrcmp (pCurNode->name, BAD_CAST "OIXInit"))
        {
			pOIXInitNode=pCurNode;
			pChgNode = pCurNode->xmlChildrenNode;
			while(pChgNode != NULL)
			{
				if((!xmlStrcmp(pChgNode->name, BAD_CAST "ALM_STN_MASK")))
				{
					sprintf(alm_stn_mask,"%u",stnMask4alarm);
					xmlNodeSetContent(pChgNode->xmlChildrenNode, alm_stn_mask);	
					//xmlFree(alm_stn_mask);
					alm_stn_mask_flag=1;
					break;
				}
				pChgNode = pChgNode->next;
			}	
			
			//if no ALM_STN_MASK node,add new node
			if (!alm_stn_mask_flag)
			{
				sprintf(alm_stn_mask,"%u",stnMask4alarm);
				xmlNewTextChild(pOIXInitNode, NULL, BAD_CAST "ALM_STN_MASK", BAD_CAST alm_stn_mask);

			}

		}
		pCurNode = pCurNode->next;
    }
	xmlSaveFormatFile(FILE_OIX_CONFIG_XML,pdoc,1);
	xmlFreeDoc(pdoc); 
	xmlCleanupParser ();
	return 0;
}
  
void
on_ok_stn_config                       (GtkButton       *button,
                                        gpointer         user_data)
{
    int crt_n =(int)user_data;
    UCHAR i;
	FILE *fp  ; 
     
	for (i = 0  ; i<32  ;i++)
	{
		if (isStnInMask(i))
		printf ("\nasdfa the stn %d on line !!!!!\n",i) ; 

	}

 
	//	stnMask4alarm  = 0xFFFFFFFF   ;
	SaveSTNMaskXml("ALM_STN_MASK");
		
	if( (fp  =fopen (FILE_OIX_DEF_DAT,"w+"))!=NULL)
	{	
		fwrite(&stnMask4alarm,sizeof(UINT),1,fp)  ; 
		fclose(fp)  ;
	}else
		printf ("OIX::Error occurs while open%s \n" ,FILE_OIX_DEF_DAT) ;
	 
 
    DestroyAlmStnCfgWin( NULL, (gpointer) crt_n);
}


void
on_cancel_stn_config                  (GtkButton       *button,
                                        gpointer         user_data)
{
    int crt_n =(int)user_data;
        
	DestroyAlmStnCfgWin( NULL, (gpointer) crt_n);
}




GtkWidget* create_alm_stn_config_win (int crt_n)
{
  
	GtkWidget *table1;

	GtkWidget *ok_btn;
	GtkWidget *Cancel_btn;
	GtkWidget *checkbtn_lcu[STATION_ENTRY_NUMBER+1] ;
    GtkWidget  *window  ; 
	UCHAR i;
	int	k,row,col;
	char	stn_name[128];
	int	stn_num;
	gchar *pConvert=0;

	static LCU_INFO lcu_info[STATION_ENTRY_NUMBER*GROUP_ENTRY_NUM_PER_STATION];
//	BOOL  alm_info_disable[STATION_ENTRY_NUMBER+1][GROUP_ENTRY_NUM_PER_STATION+1];
  
	if(!CheckUserPrivilege(cur_usr_name, PRIV_SYS_CONF_MGR))
	{
		PopupMessageBox ( main_w[crt_n], MSG_SYS_CONFIG_MGR );
		return NULL;
	}
 
	window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
	gtk_window_resize (window,200,100);
	gtk_window_set_title (GTK_WINDOW (window), pConvert=_toUtf8EX(OIX_CSTR_ALM_STN_CONFIG));
	G_SAFE_FREE(pConvert);//dzy1017
	gtk_window_set_transient_for(GTK_WINDOW(window), GTK_WINDOW(main_w[crt_n]));
	gtk_window_set_position(GTK_WINDOW(window),GTK_WIN_POS_CENTER);
 
	gtk_signal_connect(GTK_OBJECT(window),
		"destroy",
		GTK_SIGNAL_FUNC(DestroyAlmStnCfgWin),
		(gpointer)crt_n);

	GetStationNum(&stn_num);
	table1 = gtk_table_new (stn_num+2, 2, TRUE);
	gtk_widget_show (table1);
	gtk_container_add (GTK_CONTAINER (window), table1);


	k=0;
	for(i=1;i<=stn_num;i++)
	{
		UCHAR stn_id;
		
		if(-1==GetStnIdByIndex(i, &stn_id))
			continue;
		
        if(-1==GetStnCommentById(stn_id, (char*)&stn_name))
			continue;
          
        checkbtn_lcu[i]  = gtk_check_button_new_with_mnemonic (pConvert=_toUtf8(stn_name));
        G_SAFE_FREE(pConvert);//dzy1017
		gtk_widget_show (checkbtn_lcu[i] );
        row = k/5+1;
        col = k%5;
        gtk_table_attach (GTK_TABLE (table1), checkbtn_lcu[i] , row-1, row, col+1, col+2,
                (GtkAttachOptions) (GTK_FILL),
                (GtkAttachOptions) (0), 0, 0);
        
        gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (checkbtn_lcu[i]),stnMask4alarm ); 
		if (stnMask4alarm & (0X1<<(i-1)) ) 
			 gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (checkbtn_lcu[i]),TRUE ); 
		else
			 gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (checkbtn_lcu[i]), FALSE);


        g_signal_connect ((gpointer) checkbtn_lcu[i], "toggled",
                G_CALLBACK (on_checkbtn_stn_toggled),
                GINT_TO_POINTER( i));
        k++;
        
	}

	ok_btn = gtk_button_new_with_mnemonic (("Ok"));
	gtk_widget_show (ok_btn);
	gtk_table_attach (GTK_TABLE (table1), ok_btn, 0, 1, stn_num+1, stn_num+2,
					  (GtkAttachOptions) (GTK_FILL),
					  (GtkAttachOptions) (0), 0, 0);

	Cancel_btn = gtk_button_new_with_mnemonic (("Cancel"));
	gtk_widget_show (Cancel_btn);
	gtk_table_attach (GTK_TABLE (table1), Cancel_btn, 1, 2, stn_num+1, stn_num+2,
					  (GtkAttachOptions) (GTK_FILL),
					  (GtkAttachOptions) (0), 0, 0);

	g_signal_connect ((gpointer) ok_btn, "clicked",
					  G_CALLBACK (on_ok_stn_config),
					  GINT_TO_POINTER(crt_n));

	g_signal_connect ((gpointer) Cancel_btn, "clicked",
					  G_CALLBACK (on_cancel_stn_config),
					 GINT_TO_POINTER(crt_n)); 

 
	return window;
}


void  AlmConfig_active(int crt_n)
{
	
	if (alm_stn_config_win[crt_n])
		gtk_window_present(GTK_WINDOW(alm_stn_config_win[crt_n]));			
	else
	{
		alm_stn_config_win[crt_n] = create_alm_stn_config_win (  crt_n)  ;
		if (alm_stn_config_win[crt_n])
			gtk_widget_show(alm_stn_config_win[crt_n]) ;  
	}
	
	
}